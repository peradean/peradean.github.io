<!DOCTYPE html>
<html>
<head>
    <title>Chess Maze Adventure</title>
    <style>
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        #game-container {
            text-align: center;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="instructions">Click a pawn to start the maze challenge!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game states
        const STATE_CHESS = 0;
        const STATE_MAZE = 1;
        let currentState = STATE_CHESS;
        
        // Chess board setup
        let board = Array(8).fill().map(() => Array(8).fill(0));
        let completedPieces = new Set();
        let currentTheme = 0;
        const themes = [
            {boardLight: '#D2B48C', boardDark: '#8B4513', pieces: '#FFD700', completed: '#00FF00'},
            {boardLight: '#DDA0DD', boardDark: '#4B0082', pieces: '#FF69B4', completed: '#FFFF00'},
            {boardLight: '#98FB98', boardDark: '#006400', pieces: '#FFA500', completed: '#FF0000'}
        ];

        // Initialize pawns
        for(let i = 0; i < 8; i++) {
            board[1][i] = 1;
            board[6][i] = 1;
        }

        // Maze game variables
        let ball = {x: 100, y: 400, vx: 0, vy: 0, radius: 15};
        let hole = {x: 650, y: 400, radius: 25}; // Larger hole
        let isLaunching = false;
        let launchAngle = 0;
        let launchPower = 0;
        let attempts = 3; // Add retry attempts

        function drawChessBoard() {
            const theme = themes[currentTheme];
            const squareSize = canvas.width / 8;
            
            // Draw checkered pattern
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    ctx.fillStyle = (row + col) % 2 === 0 ? theme.boardLight : theme.boardDark;
                    ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                    
                    // Add subtle gradient
                    const gradient = ctx.createRadialGradient(
                        col * squareSize + squareSize/2,
                        row * squareSize + squareSize/2,
                        0,
                        col * squareSize + squareSize/2,
                        row * squareSize + squareSize/2,
                        squareSize/2
                    );
                    gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                }
            }

            // Draw pieces
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    if(board[row][col] === 1) {
                        drawPawn(col * squareSize + squareSize/2, 
                                row * squareSize + squareSize/2, 
                                theme.pieces);
                    } else if(board[row][col] === 2) {
                        drawPawn(col * squareSize + squareSize/2, 
                                row * squareSize + squareSize/2, 
                                theme.completed);
                    }
                }
            }
        }

        function drawPawn(x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.arc(x + 5, y - 5, 15, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMazeGame() {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw chasm (smaller)
            ctx.fillStyle = '#666';
            ctx.fillRect(300, 0, 200, canvas.height);
            
            // Draw ball with speed trail
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            const gradient = ctx.createLinearGradient(
                ball.x - ball.vx, ball.y - ball.vy, ball.x, ball.y
            );
            gradient.addColorStop(0, 'rgba(255,0,0,0)');
            gradient.addColorStop(1, '#FF0000');
            ctx.fillStyle = gradient;
            ctx.fillRect(ball.x - 20, ball.y - 20, 40, 40);
            
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw hole
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Launch guide
            if(isLaunching) {
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + Math.cos(launchAngle) * launchPower * 2,
                         ball.y + Math.sin(launchAngle) * launchPower * 2);
                ctx.stroke();
                
                // Attempts remaining
                ctx.fillStyle = '#FFF';
                ctx.font = '20px Arial';
                ctx.fillText(`Attempts: ${attempts}`, 10, 30);
            }
        }

        function updateMazeGame() {
            if(!isLaunching) {
                ball.vy += 0.3; // Lighter gravity
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vx *= 0.99; // Friction
                ball.vy *= 0.99;
                
                // Bounce off walls
                if(ball.x < ball.radius || ball.x > canvas.width - ball.radius) {
                    ball.vx = -ball.vx * 0.8;
                }
                if(ball.y > canvas.height - ball.radius) {
                    ball.vy = -ball.vy * 0.8;
                    ball.y = canvas.height - ball.radius;
                }
                
                // Check hole
                const dx = ball.x - hole.x;
                const dy = ball.y - hole.y;
                if(Math.sqrt(dx*dx + dy*dy) < ball.radius + hole.radius) {
                    completePiece();
                }
                
                // Check failure
                if(ball.y > canvas.height + 50 || (ball.vx === 0 && ball.vy === 0 && attempts > 0)) {
                    attempts--;
                    if(attempts > 0) {
                        resetBall();
                    } else {
                        currentState = STATE_CHESS;
                        resetBall();
                        attempts = 3;
                    }
                }
            }
        }

        function resetBall() {
            ball.x = 100;
            ball.y = 400;
            ball.vx = 0;
            ball.vy = 0;
            isLaunching = true;
        }

        function completePiece() {
            board[currentPiece.row][currentPiece.col] = 2;
            completedPieces.add(`${currentPiece.row},${currentPiece.col}`);
            currentState = STATE_CHESS;
            resetBall();
            attempts = 3;
            checkWinCondition();
        }

        function checkWinCondition() {
            if(completedPieces.size === 16) {
                alert('Congratulations! You completed the board!');
                currentTheme = (currentTheme + 1) % themes.length;
                resetGame();
            }
        }

        function resetGame() {
            board = Array(8).fill().map(() => Array(8).fill(0));
            completedPieces.clear();
            for(let i = 0; i < 8; i++) {
                board[1][i] = 1;
                board[6][i] = 1;
            }
        }

        let currentPiece = null;
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if(currentState === STATE_CHESS) {
                const squareSize = canvas.width / 8;
                const row = Math.floor(y / squareSize);
                const col = Math.floor(x / squareSize);
                
                if(board[row][col] === 1) {
                    currentPiece = {row, col};
                    currentState = STATE_MAZE;
                    resetBall();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if(isLaunching) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                launchAngle = Math.atan2(y - ball.y, x - ball.x);
                launchPower = Math.min(50, Math.sqrt((x - ball.x)**2 + (y - ball.y)**2) / 5);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if(isLaunching) {
                ball.vx = Math.cos(launchAngle) * launchPower * 0.3;
                ball.vy = Math.sin(launchAngle) * launchPower * 0.3;
                isLaunching = false;
            }
        });

        function gameLoop() {
            if(currentState === STATE_CHESS) {
                drawChessBoard();
            } else {
                drawMazeGame();
                updateMazeGame();
            }
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
